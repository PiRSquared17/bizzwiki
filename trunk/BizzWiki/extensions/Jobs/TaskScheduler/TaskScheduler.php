<?php
/*<wikitext>
{| border=1
| <b>File</b> || TaskScheduler.php
|-
| <b>Revision</b> || $Id$
|-
| <b>Author</b> || Jean-Lou Dupont
|}<br/><br/>
 
== Purpose==
The purpose of this extension is to provide flexible scheduling services to 'job' related extensions. 
The standard MW only provides 'FIFO' scheduling with a rudimentary queue draining function. On the contrary,
this extension provides a 'calendar-based' scheduler. Standard MW 'jobs' can be scheduled.

== Features ==
* Hooks on 'ClockTickEvent' generated by 'ClockTick' extension
* Calendar based scheduling - earliest deadline first

== Dependancy ==
* ClockTick extension

== History ==

== Code ==
</wikitext>*/

$wgExtensionCredits[TaskScheduler::thisType][] = array( 
	'name'    => TaskScheduler::thisName,
	'version' => StubManager::getRevisionId('$Id$'),
	'author'  => 'Jean-Lou Dupont',
	'description' => 'Provides Task Scheduling functionality', 
);
// required for logging functionality.
// The stub manager also loads this file on demand - when the special page 'log' is viewed.
require_once('TaskScheduler.i18n.php');

class TaskScheduler
{
	const thisType = 'other';
	const thisName = 'TaskScheduler';
	
	//
	var $timebase;
	static $logName = 'WikiSysop';
	var $user;
	
	// database related
	static $tableName = 'task_scheduler';
	static $fields = array(
							'ts_id',
							'ts_creation_timestamp',
							'ts_last_run_timestamp',
							'ts_next_run_timestamp',
							'ts_class',
							'ts_frequency',
							'ts_priority',
						);
	
	// error codes
	const errOK					= 0;
	const errInexistantClass	= 1;
	const errRunningTask		= 2;
	
	public function __construct()
	{
		# Add a new log type
		global $wgLogTypes, $wgLogNames, $wgLogHeaders, $wgLogActions;
		$wgLogTypes[]					= 'schlog';
		$wgLogNames  ['schlog']			= 'schlog'.'logpage';
		$wgLogHeaders['schlog']			= 'schlog'.'logpagetext';
		$wgLogActions['schlog/runok']	= 'schlog'.'-runok-entry';
		$wgLogActions['schlog/runfail']	= 'schlog'.'-runfail-entry';		
		
		global $wgMessageCache;

		$msg = $GLOBALS[ 'msg'.__CLASS__ ];
		
		foreach( $msg as $key => $value )
			$wgMessageCache->addMessages( $msg[$key], $key );		
	}

	/**
		Main entry point.
		This method is called when a 'tick' event occurs.
	 */
	public function hClockTickEvent( $timebase )
	{
		// User under which we will file the log entry
		$this->user = User::newFromName( self::$logName );
		
		$this->timebase = $timebase;
		
		// Get earliest deadline task
		$tasks = $this->getTasksToRun();
		
		if (!empty( $tasks ))
			foreach( $tasks as $task )
			{
				$code = $this->runTask( $task, &$taskErrorCode );
				$this->updateLog( $task, $code, $taskErrorCode );
				$this->updateTask( $task );
			}
		
		return true;
	}
	/**
		Returns only the tasks which are scheduled to run
		at this time.
	 */
	public function getTasksToRun()
	{
		$tasks = $this->getTasks();
		
		if (empty( $tasks ))
			return null;

		$sTasks = null;

		foreach( $tasks as $task )
		{
			// Is this the first time this task is visited?
			if ( $task['ts_last_run_timestamp'] == 0 )
			{
				$this->updateTask( $task );	
				// don't execute it just now!
				continue;
			}
			// Is it time?
			// i.e. is in the deadline in the recent past?
			// (hopefully, not too distant ;-)
			if ($this->isTimeToRun( $task ))
				$sTasks[] = $task;
		}
				
		return $sTasks;
	}
	/**
		Returns an array of all the existing tasks.
	 */
	public function getTasks()
	{
		// Get the list of tasks
		// Order by 'next_run' timestamp
		// i.e. the earliest deadline first.

		$table	= self::$tableName;
		$fields	= self::$fields;
		$index	= 'ts_next_run_timestamp';
		
		$dbr = wfGetDB(DB_SLAVE);		
		
		$res = $dbr->select($table,
							$fields,
							null,
							__METHOD__, 
							array( 'ORDER BY' => "$index ASC")  );
		
		while ( $task = $dbr->fetchObject( $res ) )
		{
			$element = null;
			foreach( self::$fields as $field )
				$element[$field] = $task->$field;
				
			$tasks[] = $element;
		}
		
		$dbr->freeResult($res);
		
		return $tasks;
	}
	/**
			Actually executes the task through its 'run()' method.
	 */
	public function runTask( &$task, &$taskErrorCode )
	{
		$classe = $task['ts_class'];
		
		// verify that a matching class definition
		// can be loaded.		
		global $wgAutoloadClasses;
		if ( !$wgAutoloadClasses[$classe] )
			return errInexistantClass;

		// this, hopefully, should not cause any problem
		$obj = new $classe;
				
		try 
		{
			// $code must not overlap with the ones
			// defined here.
			$taskErrorCode = $obj->run();
		} 
		catch( Exception $e )
		{ return errRunningTask; }
		
		return errOK;		
	}
	/**
		Verifies if the task's expected run time is
		actually in the past.
	 */
	public function isTimeToRun( &$task )
	{
		// assume it is not the time to run the task.
		$code = false;
		
		$now = wfTimestampNow();
		
		// is the task expected run time in the past?
		if ( $task['ts_next_run_timestamp'] < $now )
			$code = true;

		return $code;		
	}
	/**
		Updates the 'next_run' field of the $task.
		The calculation is made based on the 'timebase'
		variable this class received from the 'ClockTickEvent' event.
	 */
	private function updateTask( &$task )
	{
		$lr = wfTimestampNow(); 
		$nr = $this->calculateNextRun( $task );
		$id = $task['ts_id'];
		
		$table	= self::$tableName;
		
		// do the actual update in the db.
		$dbw = wfGetDB(DB_MASTER);

		$dbw->update( $table,
			array( /* SET */
				'ts_last_run_timestamp'	=> $lr,		// set
				'ts_next_run_timestamp'	=> $nr,		// set
			),
			array( 'ts_id' => $id ),		// condition
			__METHOD__ );

		$result = $dbw->affectedRows() != 0;
		
		$dbw->commit();
		
		return $result;
	}
	/**
		Calculates the task's next run time.
	 */
	private function calculateNextRun( &$task )
	{
		// next run: ($timebase * $frequency) + current time
		
		$inc = $this->timebase * $task['ts_frequency'];
		
		return wfTimestamp( TS_MW, time() + $inc );
	}
	/**
		Adds a contextual log entry.
	 */
	private function updateLog( &$task, &$code, &$taskErrorCode )
	{
		static $msgMap = array(	
								errOK 				=> 'text1',
								errInexistantClass	=> 'text1',
								errRunningTask		=> 'text2',
							);
							
		$action = ( $code == errOK ) ? 'runok':'runfail';
		$msgid  = $msgMap[$code];
		$param1 = $task['ts_class'];
		$param2 = $taskErrorCode;
		
		$message = wfMsgForContent( 'schlog-'.$action.'-'.$msgid, $param1, $param2 );
		
		$log = new LogPage( 'schlog' );
		$log->addEntry( $action, $this->user->getUserPage(), $message );
	}

} // end class declaration
?>