<?php
/*<wikitext>
{| border=1
| <b>File</b> || TaskScheduler.php
|-
| <b>Revision</b> || $Id$
|-
| <b>Author</b> || Jean-Lou Dupont
|}<br/><br/>
 
== Purpose==
The purpose of this extension is to provide flexible scheduling services to 'job' related extensions. 
The standard MW only provides 'FIFO' scheduling with a rudimentary queue draining function. On the contrary,
this extension provides a 'calendar-based' scheduler. Standard MW 'jobs' can be scheduled.

== Features ==
* Hooks on 'ClockTickEvent' generated by 'ClockTick' extension
* Calendar based scheduling - earliest deadline first

== Dependancy ==
* ClockTick extension

== History ==

== Code ==
</wikitext>*/

$wgExtensionCredits[TaskScheduler::thisType][] = array( 
	'name'    => TaskScheduler::thisName,
	'version' => StubManager::getRevisionId('$Id$'),
	'author'  => 'Jean-Lou Dupont',
	'description' => 'Provides Task Scheduling functionality', 
);
// required for logging functionality.
// The stub manager also loads this file on demand - when the special page 'log' is viewed.
require_once('TaskScheduler.i18n.php');

class TaskScheduler
{
	const thisType = 'other';
	const thisName = 'TaskScheduler';
	
	//
	var $timebase;
	
	// database related
	static $tableName = 'task_scheduler';
	static $fields = array(
							'ts_id',
							'ts_creation_timestamp',
							'ts_last_run_timestamp',
							'ts_next_run_timestamp',
							'ts_class',
							'ts_frequency',
							'ts_priority',
						);
	
	// error codes
	const errInexistantClass	= 1;
	const errRunningTask		= 2;
	
	public function __construct()
	{
		# Add a new log type
		global $wgLogTypes, $wgLogNames, $wgLogHeaders, $wgLogActions;
		$wgLogTypes[]					= 'schlog';
		$wgLogNames  ['schlog']			= 'schlog'.'logpage';
		$wgLogHeaders['schlog']			= 'schlog'.'logpagetext';
		$wgLogActions['schlog/runok']	= 'schlog'.'-runok-entry';
		$wgLogActions['schlog/runfail']	= 'schlog'.'-runfail-entry';		
		
		global $wgMessageCache;

		$msg = $GLOBALS[ 'msg'.__CLASS__ ];
		
		foreach( $msg as $key => $value )
			$wgMessageCache->addMessages( $msg[$key], $key );		
	}

	/**
		Main entry point.
		This method is called when a 'tick' event occurs.
	 */
	public function hClockTickEvent( $timebase )
	{
		$this->timebase = $timebase;
		
		// Get earliest deadline task
		$tasks = $this->getTasksToRun();
		
		foreach( $tasks as $task )
		{
			$code = $this->runTask( $task );			
			$this->updateLog( $task, $code );
		}
		
		return true;
	}
	/**
	 */
	public function getTasksToRun()
	{

		// Is it time?
		// i.e. is in the deadline in the recent past?
		// (hopefully, not too distant ;-)
		if (!$this->isTimeToRun( $task ))
			continue;

		
	}
	/**
	 */
	public function getTasks()
	{
		// Get the list of tasks
		// Order by 'next_run' timestamp
		// i.e. the earliest deadline first.

		$table	= self::$tableName;
		$fields	= self::$fields;
		$index	= 'ts_next_run_timestamp';
		
		$dbr = wfGetDB(DB_SLAVE);		
		$sql="SELECT $fields FROM $table ORDER BY $index ASC;";
		
		// resource object containing all the tasks.
		// must be iterated with 'fetchObject'
		$res = $dbr->query( $sql, __METHOD__ );
		
		while ( $task = $dbr->fetchObject( $res ) )
		{
			$element = null;
			foreach( self::$fields as $field )
				$element[$field] = $task->$field;
				
			$tasks[] = $element;
		}
		
		$dbr->freeResult($res);
		
		return $tasks;
	}
	/**
	 */
	public function runTask( &$task, &$errCode )
	{
		// assume no error will occur.
		$code = true;
		
		$classe = $task['ts_class'];
		try
		{
			$obj = new $classe;
		}
		catch( $e )
		{
			$errCode = errInexistantClass;
			return false;
		}
				
		try 
		{			
			$errCode = $obj->run();
		} 
		catch( $e )
		{
			$errCode = errRunningTask;
			return false;
		}
		
		return $code;		
	}
	/**
		Verifies if the task's expected run time is
		actually in the past.
	 */
	public function isTimeToRun( &$task )
	{
		// assume it is not the time to run the task.
		$code = false;
		
		$now = wfTimestampNow();
		
		// is the task expected run time in the past?
		if ( $task['ts_next_run_timestamp'] < $now )
			$code = true;

		return $code;		
	}
	/**
		Updates the 'next_run' field of the $task.
		The calculation is made based on the 'timebase'
		variable this class received from the 'ClockTickEvent' event.
	 */
	private function updateTask( &$task )
	{
		$lr = wfTimestampNow(); 
		$nr = $this->calculateNextRun( $task );
		$id = $task['ts_id'];
		
		// do the actual update in the db.
		$dbw = wfGetDB(DB_MASTER);

		$dbw->update( $this->tableName,
			array( /* SET */
				'ts_last_run'	=> $lr,		// set
				'rs_next_run'	=> $nr,		// set
			),
			array( 'ts_id' => $id ),		// condition
			__METHOD__ );

		$result = $dbw->affectedRows() != 0;
		
		$dbw->commit();
		
		return $result;
	}
	/**
	 */
	private function calculateNextRun( &$task )
	{
		// next run: ($timebase * $frequency) + current time
		
		$inc = $this->timebase * $task['ts_frequency'];
		
		return wfTimestamp( TS_MW, time() + $inc );
	}
	/**
	 */
	private function updateLog( &$task, &$code )
	{
		$message = wfMsgForContent( 'schlog-'.$msgid, $param1, $param2, $param3, $param4, $param5 );
		
		$log = new LogPage( 'schlog' );
		$log->addEntry( $action, $this->user->getUserPage(), $message );
		
	}

} // end class declaration
?>